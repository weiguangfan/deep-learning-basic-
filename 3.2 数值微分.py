"""
梯度法使用梯度的信息决定前进的方向。
本节将介绍梯度是什么、有什么性质等内容。在这之前，我们先来介绍一下导数。

假如你是全程马拉松选手，在开始的 10 分钟内跑了 2 千米。
如果要计算此时的奔跑速度，则为 2/10 = 0.2［千米 / 分］。
也就是说，你以 1 分钟前进0.2 千米的速度（变化）奔跑。
在这个马拉松的例子中，我们计算了“奔跑的距离”相对于“时间”发生了多大变化。
不过，这个 10 分钟跑 2 千米的计算方式，严格地讲，计算的是 10 分钟内的平均速度。
而导数表示的是某个瞬间的变化量。
因此，将 10 分钟这一时间段尽可能地缩短，
比如计算前 1 分钟奔跑的距离、前 1 秒钟奔跑的距离、前 0.1秒钟奔跑的距离......这样就可以获得某个瞬间的变化量（某个瞬时速度）。
综上，导数就是表示某个瞬间的变化量。
它可以定义成下面的式子。
d(f(x)) / dx = lim ((f(x + h) - f(x)) / h )

式（4.4）表示的是函数的导数。
左边的符号 d(f(x)) / dx 表示 f（x）关于 x 的导数，即 f（x）相对于 x 的变化程度。
式（4.4）表示的导数的含义是，x 的“微小变化”将导致函数 f（x）的值在多大程度上发生变化。
其中，表示微小变化的 h无限趋近 0，表示为lim h->0 。

接下来，我们参考式（4.4），来实现求函数的导数的程序。
如果直接实现式（4.4）的话，向 h 中赋入一个微小值，就可以计算出来了。
比如，下面的实现如何？
函数 numerical_diff(f, x) 的名称来源于数值微分的英文 numericaldifferentiation。
所谓数值微分就是用数值方法近似求解函数的导数的过程。
这个函数有两个参数，即“函数 f”和“传给函数 f 的参数x”。
乍一看这个实现没有问题，但是实际上这段代码有两处需要改进的地方。

"""

import numpy as np
import matplotlib.pyplot as plt
# 不好实现的示例
# def numerical_diff(f, x):
#     """函数的导数"""
#     h = 10e-50  # h无限接近0，由于舍入误差，会省略小数点的精细部分的数值（小数点第8位以后的数值），导致结果上的误差
#     return (f(x + h) - f(x))/h  # 0.0
"""
在上面的实现中，因为想把尽可能小的值赋给 h（可以话，想让 h 无限接近0），所以 h 使用了 10e-50（有 50 个连续的 0 的“0.00 ... 1”）这个微小值。
但是，这样反而产生了舍入误差（rounding error）。
所谓舍入误差，是指因省略小数的精细部分的数值（比如，小数点第 8 位以后的数值）而造成最终的计算结果上的误差。
比如，在 Python 中，舍入误差可如下表示。

"""
# 舍入误差，无法正确表达出来
# print(np.float32(1e-50))
"""
如上所示，如果用 float32 类型（32 位的浮点数）来表示 1e-50，就会变成 0.0，无法正确表示出来。
也就是说，使用过小的值会造成计算机出现计算上的问题。
这是第一个需要改进的地方，即将微小值 h 改为 10-4。
使用 10-4 就可以得到正确的结果。

图 4-5　真的导数（真的切线）和数值微分（近似切线）的值不同
第二个需要改进的地方与函数 f 的差分有关。
虽然上述实现中计算了函数 f在 x+h 和 x 之间的差分，但是必须注意到，这个计算从一开始就有误差。
如图4-5 所示，“真的导数”对应函数在 x 处的斜率（称为切线），但上述实现中计算的导数对应的是 (x + h) 和 x 之间的斜率。
因此，真的导数（真的切线）和上述实现中得到的导数的值在严格意义上并不一致。
这个差异的出现是因为 h 不可能无限接近 0。
如图 4-5 所示，数值微分含有误差。
为了减小这个误差，我们可以计算函数f 在 (x + h) 和 (x - h) 之间的差分。
因为这种计算方法以 x 为中心，计算它左右两边的差分，所以也称为中心差分（而 (x + h) 和 x 之间的差分称为前向差分）。
下面，我们基于上述两个要改进的点来实现数值微分（数值梯度）。
"""

def numerical_diff(f, x):
    """改进版的函数的导数"""
    h = 1e-4  # 改为1e-4， 就能正确表达
    return (f(x + h) - f(x - h))/(2 * h)  # 数值微分存在误差，采用中心差分
"""
如上所示，利用微小的差分求导数的过程称为数值微分（numericaldifferentiation）。
而基于数学式的推导求导数的过程，则用“解析性”（analytic）一词，称为“解析性求解”或者“解析性求导”。
比如，y= math.pow(x) 的导数，可以通过 d(y)/dx = 2x 解析性地求解出来。
因此，当 x = 2 时，y的导数为 4。
解析性求导得到的导数是不含误差的“真的导数”。

现在我们试着用上述的数值微分对简单函数进行求导。
先来看一个由下式表示的 2 次函数。
y = 0.01 * math.pow(x) + 0.1 * x
"""


# 简单函数构造
def function_1(x):
    return 0.01 * x**2 + 0.1*x

"""
接下来，我们来绘制这个函数的图像。
画图所用的代码如下，生成的图像如图4-6 所示。
图 4-6　y = 0.01 * math.pow(x) + 0.1 * x 的图像
"""

# 简单函数图形
x = np.arange(0.0, 20.0, 0.1)
y = function_1(x)
plt.xlabel('x')
plt.ylabel('y')
plt.plot(x, y)
plt.show()
"""
我们来计算一下这个函数在 x = 5 和 x = 10 处的导数。
这里计算的导数是 f(x) 相对于 x 的变化量，对应函数的斜率。
另外，y = 0.01 * math.pow(x) + 0.1 * x 的解析解是 d(f(x))/dx = 0.02 * x + 0.1 。
因此，在 x = 5 和 x = 10处，“真的导数”分别为 0.2 和 0.3。
和上面的结果相比，我们发现虽然严格意义上它们并不一致，但误差非常小。
实际上，误差小到基本上可以认为它们是相等的。
"""
# x=5,x=10处的数值微分，误差小到近似等于真导数
print(numerical_diff(function_1, 5))  # 0.1999999999990898
print(numerical_diff(function_1, 10))  # 0.2999999999986347

"""
现在，我们用上面的数值微分的值作为斜率，画一条直线。
结果如图 4-7 所示，可以确认这些直线确实对应函数的切线（源代码在 ch04/gradient_1d.py中）。
图 4-7 x=5　、x=10 处的切线：直线的斜率使用数值微分的值
"""

